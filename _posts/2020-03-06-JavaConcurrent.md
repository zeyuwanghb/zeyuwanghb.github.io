---
layout: post
title:  "线程池"
categories: Java并发
tags:   Java并发
author: ZyWang
excerpt: Java并发相关知识 
---

## 线程池 ##

**为什么要用线程池**

- 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的损耗。
- 提高响应速度，当任务到达时，任务可以不需要等待线程创建就能立即执行。
- 提高线程的管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池对线程进行统一分配管理、监控。

**实现Runnable和Callable接口的区别**

Runnable接口不会返回结果或抛出异常run()方法，但callable接口可以call()方法。

**执行execute()方法和submit()方法的区别是什么**

execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。

submit()方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过这个Future对象判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout，TimeUnit unit)方法会阻塞当前线程一段时间后立即返回，这时候可能任务没有执行完。

## 如何创建线程池 ##

JDK提供三种默认的线程池Executors工具类中，

- FixedThreadPool，该方法返回一定固定线程数量的线程池，该线程池中线程数量始终不变，核心线程数和最大线程数相等，当有一个新的任务提交时，若有空闲线程，则立即执行，若没有空闲线程，则加入到任务队列中等待执行，任务队列采用LinkedBlockingQueue，默认长度为Integr.MAX_VALUE。
- SingleThreadExecutor，方法返回一个只有一个线程的线程池，若多余的任务被提交到线程池，任务会被保存到一个任务队列中，带线程空闲，在执行任务，同样是LinkedBlockQueue队列，默认长度为Integer.MAX_VALUE。
- CachedThreadPool，该方法返回一个可根据实际情况调整线程数量的线程池，线程池中线程数量不确定，核心线程数为0，最大线程数为Integer.MAX_VALUE，任务队列采用SynchronousQueue，内部只包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。

以上线程池或多或少都有弊端，一搬通过ThreadPoolExecuter()来自己构造线程池。

**7个参数**

corePoolSize 核心线程数，定义了最小可以同时运行的线程数量。

maximumPoolSize 最大线程数，当队列中存放的任务到达队列容量时，当前可以同时运行的线程数量变为最大线程数。

workQueue 当新任务来的时候判断已经到达了核心线程数，则会将任务放到队列中。

keepAliveTime 当线程池中的线程数量大于核心线程数，如果此时没有新的任务提交，等待时间过后，销毁核心线程数外的线程。

unit keepAliveTime的单位

threadFactory 默认，executor创建新线程时候会用到。

handler 拒绝策略，1.抛出异常来拒绝新任务的处理；2.调用执行自己的线程运行任务；3.不处理，直接丢弃任务；4.丢弃最早的未处理的任务请求。

## 如何合理的配置线程池大小 ##

N为CPU的个数

如果是CPU密集型应用，则线程池大小设置为N+1

如果是IO密集型应用，则线程池大小设置为2N+1

最佳线程数目=(线程等待时间与线程CPU时间之比+1)*CPU数目

## 线程池中线程异常，线程池怎么处理 ##

如果是execute方法执行，可以看到异常堆栈，如果是submit方法执行，无异常堆栈。但是调用Future.get()方法时，可以捕获到异常。

不会影响线程池里面其他线程的正常执行，线程池会将此线程移除掉，在创建一个新的线程。

## 线程池执行原理 ##

![](http://www.uml.org.cn/j2ee/images/2012121931.jpg)