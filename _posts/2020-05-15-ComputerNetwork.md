---
layout: post
title:  "[转]三次握手、四次挥手 "
categories: 计算机网络
tags:    计算机网络
author: ZyWang
excerpt: 计算机网络 
---

****

# 参考资料 #

[https://www.cnblogs.com/Andya/p/7272462.html](https://www.cnblogs.com/Andya/p/7272462.html)

## 三次握手 ##

![](https://s1.ax1x.com/2020/07/18/Ugdz5t.jpg)

### 简要描述 ###

首先Client端发送连接请求报文，Server端接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也想Server端发送ACK报文，并分配资源，这样TCP连接就建立了。

### 详细描述 ###

最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。

B的TCP服务器进程首先创建传输控制块TCB，准备接受客户端连接请求，然后服务进程就处于LISTEN状态，等到客户端的连接请求，若有，则做出响应。

**第一次握手**:A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出请求连接报文段，同步标志位SYN=1，初始序号seq=x，此报文段不能携带数据，但要消耗一个序号，此时TCP客户进程进入SYN-SENT同步已发送状态。

**第二次握手**:B收到连接请求报文段后，如同意建立连接，则向A发送确认，在确认报文段中，同步标志位SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y，此时TCP服务器进入SYN-RCVD同步收到状态。

**第三次握手**:TCP客户端进程收到B的确认后，返回给B确认报文段，ACK=1，确认号为ack=y+1，序号为seq=x+1，ACK报文段可以携带数据，不携带数据则不消耗序号，TCP连接已经建立，A进入ESTABLISHED已建立连接状态。

TCP服务器收到A的确认后，也进入ESTABLISHED已建立连接状态。

## 一些知识点 ##

**TCB**：Transmission Control Block传输控制块，存储在每一个连接中的重要信息，数据发送双方对应的socket信息以及拥有装载数据的缓冲区，如TCP连接表，当前的发送和接受序号，到发送和接收缓存的指针，到重传队列的指针。

**为什么客户端要再确认一次，两次握手可不可以？**

主要是为了防止**已失效**的连接请求报文段又传送到了服务端，产生错误。如果A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传了一次连接请求，后来收到了来自B的确认，建立了连接。数据传输完毕后，就释放了连接。此时，A共发出了两个连接请求报文段，其中第一个可能因为网络延迟原因过了一会才到B，此时B误以为这是A的新连接请求，于是向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立了连接了，此时A并不会向B发出数据，浪费资源。

**Server端容易受到SYN泛洪攻击**

服务端资源是在二次握手时分配的，而客户端资源是在完成三次握手时分配的，所以服务器容易受到SYN泛洪攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client的确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因队列满而被丢弃，引起网络瘫痪。

防治措施:降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN后丢弃后续请求。

## 四次挥手 ##

![](https://s1.ax1x.com/2020/07/18/Ug6jhj.jpg)

### 简要描述 ###

假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN后，意思是说client端的数据传送已经结束了，但是server端可能还需要传输数据，所以不会关闭socket连接，可以继续发送数据，则server端会先发送ack确认报文，告诉client端请求已经收到，此时client端进入FIN-WAIT状态，继续等待server端的FIN报文，当server端确认数据发送完成后，则向client端发送FIN报文，准备关闭连接，client端收到FIN报文后，就知道可以关闭连接了，但他害怕server端不知道要关闭，所以发送ACK确认报文后进入TIME-WAIT状态，如果Server端没有收到ACK则重传，server端收到ack后，就知道可以断开连接了，client端等待2MSL后仍没有收到回复，则证明server端已关闭，client端随即关闭。

### 详细描述 ###

1.A的应用进程向其TCP发出连接释放报文段，FIN=1，序号seq=u，并停止发送数据，主动关闭TCP连接，进入FIN-WAIT-1终止等待1状态，等待B的确认。

2.B收到连接释放报文段后即发出确认报文段，ACK=1，确认号ack=u+1，序号seq=v，B进入CLOSE-WAIT关闭等待状态，此时TCP连接处于版关闭状态，A到B的连接释放。

3.A收到B的确认后，进入FIN-WAIT-2终止等待2状态，等待B发出的连接释放报文段。

4.B没有向A发送的报文之后，B发出连接释放报文段，FIN=1，ACK=1，序号seq=w，确认号ack=u+1，B进入LAST-ACK最后确认状态。等待A的确认。

5.A收到B的连接释放报文段后，对此发出确认报文段，ACK=1，seq=u+1,ack=w+1,A进入TIME-WAIT时间等待状态，此时TCP连接未释放掉，需要经过时间等待设置的2MSL后，A才会进入CLOSED状态。

## 一些知识点 ##

**总结四次挥手过程**

起初A和B都处于ESTABLISHED状态---A发出连接释放报文段并处于FIN-WAIT-1状态---B发出确认报文段且进入CLOSED-WAIT状态---A收到确认后，进入FIN-WAIT-2状态，等待B的连接释放报文段---B没有要向A发出的数据，B发出连接释放报文段且进入LAST-ACK状态---A发出确认报文后且进入TIME-WAIT状态---B收到确认报文后进入CLOSED状态---A经过等待计时器时间2MSL后，进入CLOSED状态。

**为什么要等待2MSL的时间？**

MSL最长报文段寿命Maximum Segment Lifetime，MSL=2

两个理由:1.保证A发送的最后一个ACK报文段能够到达B。2.防止已失效的连接请求报文段出现再本连接中

1.这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重启2MSL计时器，最后A和B都进入CLOSED状态。

2.A再发送完最后一个ACK报文段后，在经过2MSL，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使得下一个新连接中不会出现旧连接的报文段。

**为什么关闭需要四次握手？**

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。