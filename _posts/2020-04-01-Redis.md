---
layout: post
title:  "Redis "
categories: Redis 分布式
tags:  Redis
author: ZyWang
excerpt: Redis 
---

****

## Redis简介 ##

简单来说，Redis就是一个数据库，不过Redis的数据是存在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向。另外，redis也经常用来做分布式锁。同时，redis提供了多种不同的数据类型来支持不同的业务场景，redis支持事务、持久化、LUA脚本、多种集群方案。

## 为什么要用redis而不用map/guava做缓存？ ##

以Java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量、快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例公用一份缓存，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。

## redis线程模型 ##

内部使用**文件事件处理器**，这个文件事件处理器是单线程的，所以redis才叫单线程模型

**单线程模型**

因为基于内存操作，cpu并不是redis的瓶颈，所以不需要多线程。同时，免去线程切换、竞争、锁等开销。

文件事件处理器包括:1.多个socket 2.IO多路复用 3.文件事件分派器 4.事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)

![](https://img-blog.csdnimg.cn/20190918215924363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hwX3hweHA=,size_16,color_FFFFFF,t_70)

1.redis启动及初始化时，redis会将连接应答处理器跟“AE_READABLE”事件关联起来，接着如果客户端向redis发起连接，产生事件

2.当客户端向redis发起请求时，首先在对应socket上产生一个事件，然后IO多路复用程序会监听到socket上产生的事件，将socket放入一个队列中排队，由文件事件分派器从队列中获得socket交给对应的命令请求处理器来处理。

3.当请求处理完成，redis准备响应，就会将socket中的writeable事件跟命令回复处理器关联起来，当客户端准备好之后，IO多路复用监听到事件，将其放入队列中，然后由文件事件分派器从队列中获取socket交给命令回复处理器处理，之后向客户端返回。

**效率高的原因**

1.基于内存操作

2.非阻塞IO多路复用

3.单线程避免多线程的上下文切换，预防多线程的竞争问题。

## redis设置过期时间 ##

对redis数据库中的数据设置过期时间，在set key的时候，可以给一个expire time，过期时间，通过过期时间指定key可以存活的时间。

过期的时候怎么对key进行删除呢？

定期删除+惰性删除

定期删除:redis默认每隔100ms就随即抽取一些设置了过期时间的key，检查是否过期，如果过期就删除。

惰性删除:定期删除可以导致很多过期的key没有被删除掉，所以有了惰性删除。假如你的过期key，靠定期没有删除掉，还停留在内存里，在使用的时候，会先检查是否过期，过期就删除掉。

但是这样还是会导致大量过期的key堆积在内存中，导致redis内存耗尽，对于此，redis产生了内存淘汰机制。

## redis内存淘汰机制 ##

6中数据淘汰策略:

1.volatile-lru:从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

2.volatile-ttl:从已设置过期时间的数据中挑选将要过期的数据淘汰

3.volatile-random:从已设置过期时间的数据集中挑选任意数据淘汰

4.allkeys-lru:从所有数据中淘汰最近最少使用

5.allkeys-random:从所有数据中任意淘汰

6.no-eviction: 禁止驱逐数据

4.0以后新增两种:

1.volatile-lfu:从已设置淘汰时间的数据中挑选最不经常使用的数据淘汰

2.allkeys-lfu 

## redis持久化 ##

Redis不同于Memcached的很重⼀点就是，Redis⽀持持久化，⽽且⽀持两种不同的持久化操作。Redis的
⼀种持久化⽅式叫快照（snapshotting，RDB），另⼀种⽅式是只追加⽂件（append-only file,AOF）。

**RDB**

redis通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。


**AOF**

与快照持久化相⽐，AOF持久化 的实时性更好，因此已成为主流的持久化⽅案。默认情况下Redis没有开启AOF（append only file）⽅式的持久化。

开启AOF持久化后没执行一条指令都会将命令写入磁盘中的AOF文件

## 缓存雪崩、缓存穿透、缓存击穿 ##

缓存雪崩，指的是缓存中数据大批量的过期，很多数据缓存查不到而只能走数据库查询，导致数据库压力过大，甚至宕机。

解决:

1.缓存过期时间设置随即，防止同一时间大量数据过期现象发生。

2.设置热点数据永不过期。

3.如果缓存数据是分布式部署，将热点数据均匀分布在不同的缓存数据库中。

缓存击穿，指缓存中没有但数据库中有的数据，一般是缓存时间到期，由于并发用户特别多，引起数据库压力过大。

解决:

1.设置热点数据永不过期

2.加互斥锁

缓存穿透，指缓存中和数据库都没有的数据，而不断发起请求，导致数据库压力过大

解决:

1.接口层进行校验，如id基础校验

2.取不到的数据，可设置为k-v写为k-null，有效时间设置的短一点。

3.布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力

## 缓存和数据库双写一致性 ##