---
layout: post
title:  "Java并发(二)"
categories: Java并发
tags:   Java并发
author: ZyWang
excerpt: Java并发相关知识 
---

## 线程安全 ##

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果一样，而且其他变量的值也与预期一样，就是线程安全的。

出现线程安全问题一般是因为主内存和工作内存的数据不一致(共享数据出现问题)或者重排序导致的，其核心在于java内存模型JMM。

## JMM抽象结构 ##

![](https://s1.ax1x.com/2020/08/02/atRExf.jpg)

CPU的处理速度和内存不是一个数量级的，为了平衡这种差距，所以每个CPU都会有缓存。因此，共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存中，之后的读写操作均使用位于自己工作内存中的变量副本，在某个时刻再将变量副本写回主内存中更新。

如果线程A和B通信，如上图所示，线程A要先从主内存中将共享变量读入线程A的工作内存中并进行操作，之后将数据重新写回到主内存中，线程B从主内存中读取最新的共享变量。

## JMM的三大特性 ##

**原子性**:指的是一个操作是不可中断的，即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

**可见性**:指的是当一个线程修改了某一个共享变量的值后，其他线程是否能够立即知道这个修改。

**有序性**:程序执行时，编译期可能会进行优化从而进行指令重排，重排后的指令与原指令的顺序未必一致。

**Happen-Before原则**

有些指令是不允许重排的。

-volatile，volatile变量的写，先发生于读，保证可见性

-锁规则，unlock必然发生于随后的lock之前

-传递性，A先于B，B先于C，则A必定先于C

-线程的start()方法优先于每一个动作

-线程的所有动作优先于线程的终结

-线程的中断优先于被中断线程的代码

-对象的finalize规则，一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。
