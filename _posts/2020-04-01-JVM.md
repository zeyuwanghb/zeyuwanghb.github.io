---
layout: post
title:  "JVM(一)"
categories: Java虚拟机
tags:   JVM
author: ZyWang
excerpt: Java虚拟机知识 
---

****
## JVM主要组成部分 ##

![](https://s1.ax1x.com/2020/07/19/UWTYee.jpg)

1.类加载器(ClassLoader)

2.运行时数据区(Runtime Data Area)

3.执行引擎(Execution Engine)

4.本地接口库(Native Interface)

首先通过类加载器(ClassLoader)会把Java代码转化为字节码，运行时数据区(Runtime Data Area)再把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎(Execution Engine)，将字节码翻译成底层系统指令，再交由CPU执行，而这个过程中需要调用其他语言的本地库接口(Native Interface)来实现整个程序的功能。

## 运行时数据区 ##

**程序计数器**

PC:是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，程序的分支、循环、跳转、异常处理、线程恢复等功能都依赖此计数器来完成。

Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，再任何一个确定时刻，一个处理器只会执行一条线程中的命令，因此，每个线程都有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，此内存区域为"线程私有"的内存。

此区域无OOM异常出现。

**Java虚拟机栈**

Java虚拟机栈:描述的是Java方法执行的内存模型，每个方法执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应一个栈帧从入栈到出栈的过程，此区域是线程私有的，生命周期与线程相同。

局部变量表用来存储编译期可知的各种基本数据类型、对象引用等。

Java虚拟机栈有两种异常情况:如果请求的栈的深度大于虚拟机所允许的深度(-Xss JVM启动时每个线程分配的内存大小)，将抛出StackOverFlowError异常；如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

在单个线程情况下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配时，虚拟机抛出StackOverflowError异常；如果不限于单线程，通过不断建立线程的方式倒是可以产生OOM

**本地方法栈**

本地方法栈:与虚拟机栈的作用类似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。

同样存在StackOverflowError和OOM异常。

**Java堆内存**

Java堆内存:是被所有线程所共享的一块内存区域，在虚拟机启动时创建，此内存区域被用来存放对象实例，几乎所有的对象实例都在这里分配内存

逃逸分析

Java堆是垃圾收集器管理的主要区域，GC堆。从内存回收的角度来看，由于现在垃圾收集器(G1除外)基本采用分代收集算法，Java堆可以细分成新生代和老年代。从内存分配角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区(TLAB)，不过无论如何划分存放都是对象实例。

Java堆可以处于处理上不连续的内存空间中，只要是逻辑上连续的即可，在实现时，可以是固定大小的，也可以是可扩展的，如果无法扩展时，将会抛出OOM异常。

**方法区**

方法区:与Java堆一样，是所有线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量等数据。

运行时常量池:是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一些信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分信息将在进入方法区后存入运行时常量池。

同样会抛出OOM异常。

## 堆和栈的区别是什么 ##

堆和栈是两个完全不同的内存区域，一个线程共享的，一个线程私有的，两者之间存放的内容不同:堆中主要存放对象实例，栈(局部变量表)中存放各种基本数据类型、对象的引用。

从作用来讲，栈是运行时单位，而堆是存储单位，栈解决的是程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储问题，即数据怎么放、放在哪。栈是运行时单位，因此里面存储的信息是跟当前线程相关信息的，包括局部变量、程序运行状态、返回值等；而堆只负责存储对象信息。

##Java中的参数传递时是传值还是传引用？##

程序是运行在栈中的，因而参数传递时，只存在传递基本数据类型和对象引用的问题，不会直接传递对象本身。

Java在方法调用传递参数时，因为没有指针，所示它是进行传值调用。但会有传引用的错觉，是因为在栈中，基本数据类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法的调用，可以理解为"传引用值"的传值调用。

## 对象的访问定位的两种方式？ ##

Java程序通过栈上的引用数据来操作堆上的具体对象，目前主流的对象访问方式有:句柄和直接指针。

**使用句柄**

如果使用句柄的话，那么Java堆中将会划出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄地址包含了对象实例数据和类型数据各自的地址信息。

**直接指针**

如果使用直接指针访问，那么引用中存储的就是对象的地址，Java堆对象的布局中要考虑如何放置访问类型数据的相关信息。

**各自优点**

1.句柄的最大好处就是引用中存储的是句柄地址，对象被移动时只会改变句柄中的实例数据指针，而不会改变引用本身。

2.使用直接指针访问方式的最大好处就是速度快，节省了一次指针定位的开销。

## 判断垃圾可以回收的方法有哪些？ ##

**引用计数法**

每个对象实例都有一个引用计数，当一个对象被创建时，就将该对象实例分配给一个变量用来计数，设置为1.当任何其他变量被赋值为这个对象的引用时，计数器加1(a=b，b的引用计数器+1)，一个对象实例的某个引用超过了生命周期或者设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例被当作垃圾收集。

存在循环引用问题。

**可达性分析**

程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，所有引用节点寻找完毕后，剩余的节点则被认为是没有引用到的节点，即无用的节点，可以被当作垃圾回收。

GC ROOT的对象包括下面几种:

1.虚拟机栈中引用的对象(栈帧中的本地变量表)

2.本地方法栈中引用的对象

3.方法区中静态属性引用的对象

4.方法区中常量引用的对象

**被标记为垃圾的对象一定会被回收吗？**

即使是可达性分析算法中不可达的对象，也不一定是非死不可，暂时处于缓刑阶段，真正宣告死亡，至少要经历两次标记过程。

第一次标记:如果对象在进行可达性分析后发现没有任何GC Roots与之相连，那么它会被第一次标记。

第二次标记:第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，在finalize()方法中没有重新与引用链建立联系的，才是真正要回收的对象。如果在finalize()方法中重新建立了关联关系，将继续存活。

若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法，并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行。

## 垃圾收集算法 ##

**复制算法(主要用于新生代)**

复制算法解决内存碎片和效率问题，将内存分为大小相等的两部分，每次只使用其中的一半，当第一块内存使用完后，就把存活的对象复制到另一块内存上，然后清除第一块内存，但是此方法太浪费内存，相当于内存空间减少了一半。使用于大量对象存活率很低的场景。

**标记-清除**

标记清除算法采用从根集合(GC Roots)进行扫描，对存活的对象进行标记，标记完毕后，在扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但是会造成内存碎片。

**标记-整理**

标记-整理算法采用与标记-清除一样的方式进行对象的标记，但在清除的时候不同，再回收不存活的对象占用的空间后，会将所有的存活对象往一端移动，并更新指针，因为标记-整理算法在标记-清除算法的基础上做了对象的移动，因此成本更高，但是解决了内存碎片的问题。

**分代收集**



**三色标记法**

这个算法把GC的对象分为三种情况:

- 白色:还没搜索过的对象，白色对象会被当成垃圾对象
- 灰色:正在搜索的对象
- 黑色:搜索完成的对象，不会被当成垃圾对象，不会被GC

将所有对象首先放入白色集合中，然后从根节点开始遍历所有对象，遍历到的对象从白色集合放入灰色集合。

遍历灰色集合，将灰色对象引用的对象从白色集合再放入灰色集合，之后将此灰色对象放入黑色集合。

重复直到灰色中无任何对象，收集所有白色对象。