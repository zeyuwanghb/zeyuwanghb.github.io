---
layout: post
title:  "JVM(四)"
categories: Java虚拟机
tags:   JVM
author: ZyWang
excerpt: Java虚拟机知识 
---

## 类文件结构 ##

Class文件结构类型:

![](https://s1.ax1x.com/2020/07/25/Uzzl79.jpg)

Class文件没有任何分隔符，严格按照上面结构表中顺序排列。长度、顺序、数量都是被严格限定的。

1.魔数: 0xCAFEBABE，每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否是一个被虚拟机接受的Class文件，及判断这个文件是否符合Class文件规范

2.文件版本:minor_version和major_version

3.常量池:constant_pool_count常量池计数和const_pool，常量池中主要存放两大类常量:字面量和符号引用，字面量是文本字符串或者final的常量值，符号引用包括类或接口全限定名、字段名称和描述符、方法名称和描述符

4.访问标志:用于标识一些类或者接口层次的访问信息，表示是接口或者类、是否为public、final、static等等。

5.类索引、父类索引与接口索引集合:确定类的继承关系，指向常量池中的常量索引

6.字段表集合:类或接口中声明的变量，只包含成员变量和静态变量，使用一个计数器先统计字段个数

7.方法表集合:描述该类中的方法，使用一个计数器先统计方法个数

8.属性表集合:主要存放javac编译器处理后的得到的字节码指令，包括最大栈深度，字节码指令的数量等等。

## 类加载机制 ##

JVM把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

类的声明周期包括:加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备、解析称为连接。

![](https://s1.ax1x.com/2020/07/26/apfIED.jpg)

**各个阶段的作用**

1.加载:通过累的全限定名来获取二进制字节流，将字节流所代表的类的静态信息加载到方法区的运行时常量池，在堆中生成一个java.lang.Class对象，作为方法区这个类的各种数据的访问接口。

2.连接:验证，确保Class文件的字节流中包含的信息符合当前虚拟机的要求，格式验证、元数据验证、符号引用验证；准备，为类变量分配内存和设置类变量初始值的阶段，在方法区中分配，被static修饰的变量，而不是实例变量，实例化不是类加载的过程，类加载发生在实例化操作之前，并且类加载只进行一次，实例化可以进行多次，同时分配的初始值为0或者null或者false，只有常量(final)才会按照表达式来初始化；解析，将常量池内的符号引用(一组符号，class文件中经常以常量形式出现)替换为直接引用(直接指向目标的指针、相对偏移量、句柄等)的过程。

3.初始化:准备阶段，变量已经赋值过一次系统要求的初始值了，而在初始化阶段，则根据程序员的表达式去初始化类变量和其他资源，初始化阶段是执行类构造器<clinit>()方法的过程，clinit()方法由静态变量和静态代码块组成，一个类中可以没有clinit方法，父类静态变量初始化、父类静态代码块、子类静态变量初始化、子类静态代码块，只执行一次。


## 类加载器 ##

1.启动类加载器(BootStrap ClassLoader)用C++实现的，虚拟机自身的一部分，负责加载存在于<JAVA_HOME>/lib和jre目录中的(例如rt.jar)，或者被-Xbootclasspath参数指定的路径中的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null即可。

2.其它类加载器:由Java语言实现，独立于虚拟机外部，全部继承自抽象类java.lang.ClassLoader，如扩展类加载器和应用类加载器。

扩展类加载器:Extension ClassLoader，负责加载<JAVA_HOME>/lib/ext目录下的，或者dirs系统变量所指定的类库，可被开发者直接使用。

应用程序类加载器:Application ClassLoader，此类加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以一般也称为系统类加载器，复制加载用户路径所指定的类库，开发者可直接使用，如果程序中没有定义过自己的类加载器，一般情况下就是默认的类加载器。

**类和类加载器的关系**

类加载器虽然只用于实现类的加载动作，但在Java程序中起到的作用却不限于类加载阶段。任意一个类，都需要由它的类加载器和类本身一同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间，比较两个类是否一致，必须要是在同一个类加载器加载的前提下才有意义，否则，即使是同一个Class文件，两个类也不相等。

## 双亲委派模型 ##

每一个类加载器收到类加载请求后，它首先不会自己尝试去加载这个类，而是把这个加载请求委派给父类加载器去完成。每一层的类加载器都是如此，因此所有的类加载请求都会传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会自己尝试去加载。

这样的话类随着类加载器一起具备了一种带有优先级的层次关系，例如类java.lang.Object，它存放在rt.jar包中，无论哪一个类加载器加载这个类，都由最顶端的启动类加载器加载，因此Object类在程序的各种类加载器环境中都是同一个类，使用同一个类加载器加载。反之，假如用户自己编写一个Object类然后自行加载，就会出现多个不同的Object类，系统就会混乱。

实现双亲委派:java.lang.ClassLoader()的loadClass()方法中，先检查是否已经被加载过，么有就调用父类的loadClass()方法，若父类加载器为空，默认使用启动类加载器作为父类加载器，如果父类加载失败，抛出ClassNotFoundException异常后，在调用自己的findClass()方法进行加载。

## 自定义类加载器 ##

继承java.lang.ClassLoader类，并重写findClass()方法即可。

## 打破双亲委派模型 ##

1.自己写一个类加载器

2.重写loadClass()方法

3.重写findClass()方法

这里最主要的是重写loadClass()方法，因为双亲委派机制都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载，在由自己的findClass()方法来加载，源码里面会直接找到根加载器，重写此方法后就能自己定义加载方法了。

需要破坏双亲委派的场景:在jdk中存在api调用用户代码的情况，典型的如SPI代码。

	SPI机制简介 SPI的全名为Service Provider Interface，主要是应用于厂商自定义组件或插件中。
	在java.util.ServiceLoader的文档里有比较详细的介绍。
	简单的总结下java SPI机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml解析模块、jdbc模块等方案。
	面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。
	为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。
	Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。

所以jdk开发人员引入了线程上下文类加载器(Thread Context ClassLoader)，这类类加载器可以通过java.lang.Thread类的setContextClassLoader方法设置。

在jdbc的使用中，就有很好的体现，我们会配置mysql的加载项，通过java库获取数据库连接。

最终会由启动类加载器拿到了系统类加载器加载的类，打破双亲委派模型。